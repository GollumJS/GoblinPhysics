<!DOCTYPE html>
<html>
<head>
	<title>Ray Tracing | Goblin Physics</title>

	<link rel="stylesheet" type="text/css" href="css/styles.css"/>
	<link rel="stylesheet" type="text/css" href="css/mocha.css"/>
	<script type="text/javascript" src="js/chai.js"></script>
	<script type="text/javascript" src="js/mocha.js"></script>
	<script type="text/javascript" src="../lib/three.min.js"></script>
	<script type="text/javascript" src="../lib/gl-matrix-min.js"></script>
	<script type="text/javascript" src="../build/goblin.js"></script>
	<script type="text/javascript" src="js/testUtils.js"></script>

	<script type="text/javascript">
		mocha.ui('bdd');
		var assert = (typeof chai !== "undefined" && chai !== null ? chai.assert : void 0) || require('chai').assert;
		window.onload = function() {
			testUtils.initialize(); // Creates Three.js renderer & GoblinPhysics world

			(function(){
				Goblin.EPSILON = 0.01;

				var sphere = testUtils.createSphere( 2, 0 ); // radius, mass
					/*box = testUtils.createBox( 3, 4, 5, 1 ), // half width (x), half height (y), half length (z), mass
					cylinder = testUtils.createCylinder( 3, 2.5, 1 ), // radius, half height, mass
					cone = testUtils.createCone( 3, 2.5, 1 ), // radius, half height, mass
					plane_x = testUtils.createPlane( 0, 5, 10, 1 ), // orientation, half_width, half_length, mass
					plane_y = testUtils.createPlane( 1, 5, 10, 1 ), // orientation, half_width, half_length, mass
					plane_z = testUtils.createPlane( 2, 5, 10, 1 ); // orientation, half_width, half_length, mass*/

				sphere.material.transparent = true;
				sphere.material.opacity = 0.6;

				describe('Sphere', function(){

					it('Base Sphere 1', function(){
						var start = vec3.createFrom( -4, 0, 0 ),
							stop = vec3.createFrom( 4, 0, 0 ),
							expected = vec3.createFrom( -2, 0, 0 ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Base Sphere 2', function(){
						var start = vec3.createFrom( 0, 2, 2 ),
							stop = vec3.createFrom( 0, -2, -2 ),
							expected = vec3.createFrom( 0, Math.sqrt( 2 ), Math.sqrt( 2 ) ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Base Sphere 2', function(){
						var start = vec3.createFrom( 0, 0, 0 ),
							stop = vec3.createFrom( 2, 0, -2 ),
							expected = vec3.createFrom( Math.sqrt( 2 ), 0, -Math.sqrt( 2 ) ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});


					it('Translated Sphere 1', function(){
						var start = vec3.createFrom( 2, 3, 0 ),
							stop = vec3.createFrom( 2, 1, 0 ),
							expected = vec3.createFrom( 2, 1, 0 ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.position = vec3.createFrom( 2, 3, 0 );
						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Translated Sphere 2', function(){
						var start = vec3.createFrom( 0, 5, 0 ),
							stop = vec3.createFrom( 4, 5, 0 ),
							expected = vec3.createFrom( 2, 5, 0 ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.position = vec3.createFrom( 2, 3, 0 );
						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Rotated Sphere 1', function(){
						var start = vec3.createFrom( -4, 0, 0 ),
							stop = vec3.createFrom( 4, 0, 0 ),
							expected = vec3.createFrom( -2, 0, 0 ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.position = vec3.create();
						sphere.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Rotated Sphere 2', function(){
						var start = vec3.createFrom( 0, 2, 2 ),
							stop = vec3.createFrom( 0, -2, -2 ),
							expected = vec3.createFrom( 0, Math.sqrt( 2 ), Math.sqrt( 2 ) ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.position = vec3.create();
						sphere.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) );
						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Sphere 1', function(){
						var start = vec3.createFrom( -10, 0, 1 ),
							stop = vec3.createFrom( 10, 0, 1 ),
							expected = vec3.createFrom( 4.13, 0, 1  ),
							intersection_list = new Goblin.LinkedList();

						sphere.goblin.position = vec3.createFrom( 5, 1.5, 0 );
						sphere.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0.5, 1 ) );
						sphere.goblin.updateDerived();
						sphere.goblin.rayIntersect( start, stop, intersection_list );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( intersection_list.first.point, expected ) ), 0 ) );
					});
                });
				return;
				describe('Box', function(){
					it('Base Box 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 3, 4, 5 );

						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base Box 2', function(){
						var direction = vec3.createFrom( 0, -1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 3, -4, -5 );

						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Box 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 4, 7, 10 );

						box.goblin.position = vec3.createFrom( 1, 3, 5 );
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Box 2', function(){
						var direction = vec3.createFrom( -1, -0.2, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( -5, -4, 85 );

						box.goblin.position = vec3.createFrom( -2, 0, 80 );
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Box 1', function(){
						var direction = vec3.createFrom( 1, 0, 1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 4, 3 );

						box.goblin.position = vec3.create();
						box.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) ); // 90 degrees around Y axis
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Box 2', function(){
						var direction = vec3.createFrom( -1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( -1.423, 4, -5.655 );

						box.goblin.position = vec3.create();
						box.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 0.415, 0, 1 ) ); // 45 degrees around Y axis
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Box 1', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 7, 7, -3 );

						box.goblin.position = vec3.createFrom( 2, 3, 0 );
						box.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) ); // 90 degrees
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Box 2', function(){
						var direction = vec3.createFrom( -1, -1, 1 ),
							point = vec3.create(),
							expected = vec3.createFrom( -3.66, -1, -1.41 );

						box.goblin.position = vec3.createFrom( 2, 3, 0 );
						box.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 0.415, 0, 1 ) ); // 45 degrees
						box.goblin.updateDerived();
						box.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});

				describe('Cylinder', function(){
					it('Base Cylinder 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 3, 2.5, 0 );

						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base Cylinder 2', function(){
						var direction = vec3.createFrom( 0, -1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, -2.5, 0 );

						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base Cylinder 3', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( Math.sqrt( 4.5 ), 2.5, -Math.sqrt( 4.5 ) );

						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Cylinder 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 5.5, 0 );

						cylinder.goblin.position = vec3.createFrom( 2, 3, 0 );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Cylinder 2', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 2 + Math.sqrt( 4.5 ), 5.5, -Math.sqrt( 4.5 ) );

						cylinder.goblin.position = vec3.createFrom( 2, 3, 0 );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Cylinder 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 3, 0, 2.5 );

						cylinder.goblin.position = vec3.create();
						cylinder.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Cylinder 2', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( Math.sqrt( 4.5 ), Math.sqrt( 4.5 ), -2.5 );

						cylinder.goblin.position = vec3.create();
						cylinder.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Cylinder 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 3, 2.5 );

						cylinder.goblin.position = vec3.createFrom( 2, 3, 0 );
						cylinder.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Cylinder 2', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 4.121, 5.121, -2.5 );

						cylinder.goblin.position = vec3.createFrom( 2, 3, 0 );
						cylinder.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cylinder.goblin.updateDerived();
						cylinder.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});

				describe('Cone', function(){
					it('Base Cone 1', function(){
						var direction = vec3.createFrom( 0, 1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, 2.5, 0 );

						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base Cone 2', function(){
						var direction = vec3.createFrom( 0, -1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, -2.5, 0 );

						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base Cone 3', function(){
						var direction = vec3.createFrom( 1, -1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( Math.sqrt( 4.5 ), -2.5, -Math.sqrt( 4.5 ) );

						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Cone 1', function(){
						var direction = vec3.createFrom( 0, 1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 2, 5.5, 0 );

						cone.goblin.position = vec3.createFrom( 2, 3, 0 );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated Cone 2', function(){
						var direction = vec3.createFrom( 1, -1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 2 + Math.sqrt( 4.5 ), 0.5, -Math.sqrt( 4.5 ) );

						cone.goblin.position = vec3.createFrom( 2, 3, 0 );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Cone 1', function(){
						var direction = vec3.createFrom( 0, 1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, 3, -2.5 );

						cone.goblin.position = vec3.create();
						cone.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated Cone 2', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( Math.sqrt( 4.5 ), Math.sqrt( 4.5 ), -2.5 );

						cone.goblin.position = vec3.create();
						cone.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Cone 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 3, -2.5 );

						cone.goblin.position = vec3.createFrom( 2, 3, 0 );
						cone.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated Cone 2', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 4.121, 5.121, -2.5 );

						cone.goblin.position = vec3.createFrom( 2, 3, 0 );
						cone.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) );
						cone.goblin.updateDerived();
						cone.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});

				describe('PlaneX', function(){
					it('Base PlaneX 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, 5, 10 );

						plane_x.goblin.updateDerived();
						plane_x.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base PlaneX 2', function(){
						var direction = vec3.createFrom( 0, -1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, -5, 10 );

						plane_x.goblin.updateDerived();
						plane_x.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated PlaneX', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 0, -9.99, 5 );

						plane_x.goblin.position = vec3.create();
						plane_x.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) ); // 90 degrees around X axis
						plane_x.goblin.updateDerived();
						plane_x.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated PlaneX', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 11.99, 8, 0 );

						plane_x.goblin.position = vec3.createFrom( 2, 3, 0 );
						plane_x.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) ); // 90 degrees
						plane_x.goblin.updateDerived();
						plane_x.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});

				describe('PlaneY', function(){
					it('Base PlaneY 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 0, 10 );

						plane_y.goblin.updateDerived();
						plane_y.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base PlaneY 2', function(){
						var direction = vec3.createFrom( 0, -1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 0, 10 );

						plane_y.goblin.updateDerived();
						plane_y.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated PlaneY', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, -9.99, 0 );

						plane_y.goblin.position = vec3.create();
						plane_y.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) ); // 90 degrees around X axis
						plane_y.goblin.updateDerived();
						plane_y.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated PlaneY', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 12, 3, -4.99 );

						plane_y.goblin.position = vec3.createFrom( 2, 3, 0 );
						plane_y.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) ); // 90 degrees
						plane_y.goblin.updateDerived();
						plane_y.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});

				describe('PlaneZ', function(){
					it('Base PlaneZ 1', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 10, 0 );

						plane_z.goblin.updateDerived();
						plane_z.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Base PlaneZ 2', function(){
						var direction = vec3.createFrom( 0, -1, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, -10, 0 );

						plane_z.goblin.updateDerived();
						plane_z.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Rotated PlaneZ', function(){
						var direction = vec3.createFrom( 1, 0, 0 ),
							point = vec3.create(),
							expected = vec3.createFrom( 5, 0, 9.99 );

						plane_z.goblin.position = vec3.create();
						plane_z.goblin.rotation = quat4.normalize( quat4.createFrom( 1, 0, 0, 1 ) ); // 90 degrees around X axis
						plane_z.goblin.updateDerived();
						plane_z.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});

					it('Translated & Rotated PlaneZ', function(){
						var direction = vec3.createFrom( 1, 1, -1 ),
							point = vec3.create(),
							expected = vec3.createFrom( 2, 13, -4.99 );

						plane_z.goblin.position = vec3.createFrom( 2, 3, 0 );
						plane_z.goblin.rotation = quat4.normalize( quat4.createFrom( 0, 1, 0, 1 ) ); // 90 degrees
						plane_z.goblin.updateDerived();
						plane_z.goblin.findSupportPoint( direction, point );

						return assert( testUtils.withinEpsilon( vec3.length( vec3.subtract( point, expected ) ), 0 ) );
					});
				});
			})();

            mocha.run();
		};
	</script>
</head>

<body>
	<div id="mocha"></div>
</body>
</html>