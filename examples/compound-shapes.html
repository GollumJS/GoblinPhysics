<!DOCTYPE html>
<html>
<head>
	<title>Goblin Testbed</title>

	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>

	<script type="text/javascript" src="../lib/three.min.js"></script>
	<script type="text/javascript" src="../lib/gl-matrix-min.js"></script>
	<script type="text/javascript" src="../build/goblin.js"></script>

	<script type="text/javascript">
		window.onload = function() {
			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene;
			window.scene = scene;

			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .01, 1000 );
			camera.position.set( 0, 9, 21 );
			camera.lookAt( scene.position );

			var controls = new THREE.TrackballControls( camera, renderer.domElement );
            
            var world = new Goblin.World( new Goblin.BasicBroadphase, new Goblin.NearPhase, new Goblin.SequentialImpulseSolver );
			//world.solver.relaxation = 0.2; // This example looks better with softer relaxation
			window.world = world;

			var i, particles, particles = [];

			// Ground object
			particle = new THREE.Mesh(
				new THREE.CubeGeometry( 20, 2, 20 ),
				new THREE.MeshNormalMaterial({ polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 10 })
			);

			var groundcompound = new Goblin.CompoundShape();
			groundcompound.addChildShape(
				new Goblin.BoxShape( 10, 1, 10 ),
				vec3.create(),
				quat4.createFrom( 0, 0, 0, 1 )
			);
			particle.goblin = new Goblin.RigidBody(
				//new Goblin.BoxShape( 10, 1, 10 ),
				groundcompound,
				Infinity
			);
			//particle.goblin.rotation[2] = -0.03;

			particle.position.set( 0, -5, 0 );
			particle.useQuaternion = true;

			particle.goblin.position[0] = particle.position.x;
			particle.goblin.position[1] = particle.position.y;
			particle.goblin.position[2] = particle.position.z;
			scene.add( particle );
			particles.push( particle );
			world.addRigidBody( particle.goblin );

			function spawn() {
				var boxshape = new Goblin.BoxShape( 1, 0.125, 0.5 ),
					sphereshape = new Goblin.SphereShape( 1 ),
					compoundshape = new Goblin.CompoundShape();

				/*compoundshape.addChildShape(
					sphereshape,
					vec3.createFrom( 0, -0.5, 0 ),
					quat4.createFrom( 0, 0, 0, 1 )
				);

				compoundshape.addChildShape(
					sphereshape,
					vec3.createFrom( 0, 0.5, 0 ),
					quat4.createFrom( 0, 0, 0, 1 )
				);*/

				compoundshape.addChildShape(
					boxshape,
					vec3.createFrom( 0, 0, 0 ),
					quat4.createFrom( 0, 0, 0, 1 )
				);

				compoundshape.addChildShape(
					boxshape,
					vec3.createFrom( 0, 0, 0 ),
					quat4.normalize( quat4.createFrom( 0, 0, 1, 1 ) )
				);

				particle = new THREE.Object3D();

				var sphere1 = new THREE.Mesh(
					new THREE.SphereGeometry( 1 ),
					new THREE.MeshNormalMaterial()
				);
				sphere1.position.x = 0;
				sphere1.position.y = -0.5;
				//particle.add( sphere1 );

				var sphere2 = new THREE.Mesh(
					new THREE.SphereGeometry( 1 ),
					new THREE.MeshNormalMaterial()
				);
				sphere2.position.y = 0.5;
				//particle.add( sphere2 );

				var box1 = new THREE.Mesh(
					new THREE.CubeGeometry( 2, 0.25, 1 ),
					new THREE.MeshNormalMaterial({ opacity: 1 })
				);
				particle.add( box1 );

				var box2 = new THREE.Mesh(
					new THREE.CubeGeometry( 2, 0.25, 1 ),
					new THREE.MeshNormalMaterial({ opacity: 1 })
				);
				//box2.position.x = -1;
				box2.rotation.z = Math.PI / -2;
				particle.add( box2 );

				particle.goblin = new Goblin.RigidBody( compoundshape, 1 );

				//particle.position.set( Math.random() * 3, 10, Math.random() * 3 );
				particle.position.set( 0, -3, 0 );
				particle.goblin.rotation[2] = 0.3;
				particle.useQuaternion = true;

				particle.goblin.position[0] = particle.position.x;
				particle.goblin.position[1] = particle.position.y;
				particle.goblin.position[2] = particle.position.z;
				particle.goblin.restitution = 0;
				scene.add( particle );
				particles.push( particle );
				world.addRigidBody( particle.goblin );

				//setTimeout( spawn, 500 );

				var ball = new THREE.Mesh(
					new THREE.SphereGeometry( 0.5 ),
					new THREE.MeshNormalMaterial()
				);
				ball.goblin = new Goblin.RigidBody(
					new Goblin.SphereShape( 0.5 ),
					1
				);
				scene.add( ball );
				world.addRigidBody( ball.goblin );
				particles.push( ball );
			}
			window.spawn = spawn;
			spawn();

			window.particles = particles;

			var contacts = null;

			var render = function() {
				controls.update();

				try {
                    world.step( 1 / 60 );
				}
				catch(e){
					window.stop = true;
					throw e;
				}
				if ( window.stop !== true ) {
					requestAnimationFrame( render );
				}

				var i, particle;
				for ( i = 0; i < particles.length; i++ ) {
					particle = particles[i];
					particle.position.set(
						particle.goblin.position[0],
						particle.goblin.position[1],
						particle.goblin.position[2]
					);
					particle.quaternion.set(
						particle.goblin.rotation[0],
						particle.goblin.rotation[1],
						particle.goblin.rotation[2],
						particle.goblin.rotation[3]
					);
				}

				if ( contacts ) {
					scene.remove( contacts );
				}
				contacts = new THREE.Object3D();
				scene.add( contacts );
				for ( i = 0; i < world.solver.contact_constraints.length; i++ ) {
					var point = world.solver.contact_constraints[i].contact.contact_point,
						contact = new THREE.Mesh(
							new THREE.SphereGeometry( 0.1 ),
							new THREE.MeshBasicMaterial({ color: 0x0000FF })
						);
					contact.position.set( point[0], point[1], point[2] );
					contacts.add( contact );
				}

				renderer.render( scene, camera );
			};
			window.render = render;
			render();
		};
	</script>
</head>

<body>

</body>
</html>