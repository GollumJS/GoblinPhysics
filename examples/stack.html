<!DOCTYPE html>
<html>
<head>
	<title>Goblin Testbed</title>

	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>

	<script type="text/javascript" src="../lib/three.min.js"></script>
	<script type="text/javascript" src="../lib/TrackballControls.js"></script>
	<script type="text/javascript" src="../lib/gl-matrix-min.js"></script>
	<script type="text/javascript" src="../build/goblin.js"></script>

	<script type="text/javascript">
		setMatrixArrayType( Array );
		window.onload = function() {
			var renderer = new THREE.WebGLRenderer({ antialias: true });
			//var renderer = new THREE.CanvasRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene;
			window.scene = scene;

			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .01, 1000 );
			camera.position.set( 0, 11, 24 );
			camera.lookAt( scene.position );

			var controls = new THREE.TrackballControls( camera, renderer.domElement );
            
            var world = new Goblin.World( new Goblin.BasicBroadphase, new Goblin.NearPhase, new Goblin.SequentialImpulseSolver );
			window.world = world;

			var i, particles, particles = [];

			// Ground object
			particle = new THREE.Mesh(
				new THREE.BoxGeometry( 10, 0.4, 10 ),
				new THREE.MeshNormalMaterial({ opacity: 1 })
			);
			particle.goblin = new Goblin.RigidBody(
				new Goblin.BoxShape( 5, 0.2, 5 ),
				Infinity
			);
			particle.position.set( 0, -0.5, 0 ); // -0.45

			particle.goblin.position[0] = particle.position.x;
			particle.goblin.position[1] = particle.position.y;
			particle.goblin.position[2] = particle.position.z;
			scene.add( particle );
			particles.push( particle );
			world.addRigidBody( particle.goblin );

			var i, j, k;
			for ( i = 0; i < 8; i++ ) {
				for ( j = 0; j < 8 - i; j++ ) {
					for ( k = 0; k < 8 - i; k++ ) {
						particle = new THREE.Mesh(
							new THREE.BoxGeometry( 1, 1, 1 ),
							new THREE.MeshNormalMaterial({ opacity: 1 })
						);
						scene.add( particle );

						particle.goblin = new Goblin.RigidBody(
							new Goblin.BoxShape( 0.5, 0.5, 0.5 ),
							1
						);
						particle.goblin.position[0] = j * 1.2 - 4 + ( 0.5 * i );
						particle.goblin.position[1] = i * 2.2 + 0.25;
						particle.goblin.position[2] = k * 1.2 - 4 + ( 0.5 * i );
						particles.push( particle );
						world.addRigidBody( particle.goblin );
					}
				}
			}

			setTimeout(
				function() {
					//particles[1].goblin.linear_velocity[0] = particles[1].goblin.linear_velocity[2] = 50;
				},
				5000
			);

			window.particles = particles;

            window.renderSimplex = function( simplex ) {
                /*var vertices = [];
                for ( i = 0; i < simplex.points.length; i++ ) {
                    vertices.push(
                        new THREE.Vector3(
                            simplex.points[i].point[0],
                            simplex.points[i].point[1],
                            simplex.points[i].point[2]
                        )
                    )
                }
                var geom = new THREE.ConvexGeometry( vertices );*/

                var geom = new THREE.Geometry();
                for ( i = 0; i < simplex.points.length; i++ ) {
                    geom.vertices.push(
                        new THREE.Vector3(
                            simplex.points[i].point[0],
                            simplex.points[i].point[1],
                            simplex.points[i].point[2]
                        )
                    )
                }
                geom.faces.push(
                    new THREE.Face3( 0, 1, 3 ),
                    new THREE.Face3( 1, 2, 3 ),
                    new THREE.Face3( 3, 0, 2 ),
                    new THREE.Face3( 0, 1, 2 )
                );
                geom.computeFaceNormals();

                var mesh = new THREE.Mesh(
                    geom, new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.8 })
                );
                scene.add( mesh );

                var origin = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 })
                );
                scene.add( origin );

                window.renderSimplex = function(){};
            };

            /*world.gravity[1] = 0;
            particles[1].goblin.rotation = quat4.createFrom( 0.11419094971141182, 0.00337722779961657, 0.07304665703396503, 0.9907639513186567 );
            particles[1].goblin.position = vec3.createFrom( -4.052796330070123, 0.16155278164660558, 0.8924629691970809 );
            //particles[1].goblin.position[1] = 0;*/

			var render = function() {
				controls.update();

				try {
					world.step( 1 / 60 );
				}
				catch(e){
					window.stop = true;
					throw e;
				}
				if ( window.stop !== true ) {
					requestAnimationFrame( render );
					//setTimeout( render, 50 );
				}

				var i, particle;
				for ( i = 0; i < particles.length; i++ ) {
					particle = particles[i];
					particle.position.set(
						particle.goblin.position[0],
						particle.goblin.position[1],
						particle.goblin.position[2]
					);
					particle.quaternion.set(
						particle.goblin.rotation[0],
						particle.goblin.rotation[1],
						particle.goblin.rotation[2],
						particle.goblin.rotation[3]
					);
				}
				renderer.render( scene, camera );
			};
			window.render = render;
			render();
		};
	</script>
</head>

<body>

</body>
</html>